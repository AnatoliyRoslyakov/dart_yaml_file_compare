// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'format_text_bloc.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#custom-getters-and-methods');

/// @nodoc
mixin _$FormatTextEvent {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() switchFormat,
    required TResult Function(String? file1, String? file2, String key) value,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? switchFormat,
    TResult? Function(String? file1, String? file2, String key)? value,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? switchFormat,
    TResult Function(String? file1, String? file2, String key)? value,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(SwitchFormatTextEvent value) switchFormat,
    required TResult Function(ValueFormatTextEvent value) value,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(SwitchFormatTextEvent value)? switchFormat,
    TResult? Function(ValueFormatTextEvent value)? value,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(SwitchFormatTextEvent value)? switchFormat,
    TResult Function(ValueFormatTextEvent value)? value,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $FormatTextEventCopyWith<$Res> {
  factory $FormatTextEventCopyWith(
          FormatTextEvent value, $Res Function(FormatTextEvent) then) =
      _$FormatTextEventCopyWithImpl<$Res, FormatTextEvent>;
}

/// @nodoc
class _$FormatTextEventCopyWithImpl<$Res, $Val extends FormatTextEvent>
    implements $FormatTextEventCopyWith<$Res> {
  _$FormatTextEventCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;
}

/// @nodoc
abstract class _$$SwitchFormatTextEventCopyWith<$Res> {
  factory _$$SwitchFormatTextEventCopyWith(_$SwitchFormatTextEvent value,
          $Res Function(_$SwitchFormatTextEvent) then) =
      __$$SwitchFormatTextEventCopyWithImpl<$Res>;
}

/// @nodoc
class __$$SwitchFormatTextEventCopyWithImpl<$Res>
    extends _$FormatTextEventCopyWithImpl<$Res, _$SwitchFormatTextEvent>
    implements _$$SwitchFormatTextEventCopyWith<$Res> {
  __$$SwitchFormatTextEventCopyWithImpl(_$SwitchFormatTextEvent _value,
      $Res Function(_$SwitchFormatTextEvent) _then)
      : super(_value, _then);
}

/// @nodoc

class _$SwitchFormatTextEvent extends SwitchFormatTextEvent {
  const _$SwitchFormatTextEvent() : super._();

  @override
  String toString() {
    return 'FormatTextEvent.switchFormat()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$SwitchFormatTextEvent);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() switchFormat,
    required TResult Function(String? file1, String? file2, String key) value,
  }) {
    return switchFormat();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? switchFormat,
    TResult? Function(String? file1, String? file2, String key)? value,
  }) {
    return switchFormat?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? switchFormat,
    TResult Function(String? file1, String? file2, String key)? value,
    required TResult orElse(),
  }) {
    if (switchFormat != null) {
      return switchFormat();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(SwitchFormatTextEvent value) switchFormat,
    required TResult Function(ValueFormatTextEvent value) value,
  }) {
    return switchFormat(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(SwitchFormatTextEvent value)? switchFormat,
    TResult? Function(ValueFormatTextEvent value)? value,
  }) {
    return switchFormat?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(SwitchFormatTextEvent value)? switchFormat,
    TResult Function(ValueFormatTextEvent value)? value,
    required TResult orElse(),
  }) {
    if (switchFormat != null) {
      return switchFormat(this);
    }
    return orElse();
  }
}

abstract class SwitchFormatTextEvent extends FormatTextEvent {
  const factory SwitchFormatTextEvent() = _$SwitchFormatTextEvent;
  const SwitchFormatTextEvent._() : super._();
}

/// @nodoc
abstract class _$$ValueFormatTextEventCopyWith<$Res> {
  factory _$$ValueFormatTextEventCopyWith(_$ValueFormatTextEvent value,
          $Res Function(_$ValueFormatTextEvent) then) =
      __$$ValueFormatTextEventCopyWithImpl<$Res>;
  @useResult
  $Res call({String? file1, String? file2, String key});
}

/// @nodoc
class __$$ValueFormatTextEventCopyWithImpl<$Res>
    extends _$FormatTextEventCopyWithImpl<$Res, _$ValueFormatTextEvent>
    implements _$$ValueFormatTextEventCopyWith<$Res> {
  __$$ValueFormatTextEventCopyWithImpl(_$ValueFormatTextEvent _value,
      $Res Function(_$ValueFormatTextEvent) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? file1 = freezed,
    Object? file2 = freezed,
    Object? key = null,
  }) {
    return _then(_$ValueFormatTextEvent(
      freezed == file1
          ? _value.file1
          : file1 // ignore: cast_nullable_to_non_nullable
              as String?,
      freezed == file2
          ? _value.file2
          : file2 // ignore: cast_nullable_to_non_nullable
              as String?,
      null == key
          ? _value.key
          : key // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc

class _$ValueFormatTextEvent extends ValueFormatTextEvent {
  const _$ValueFormatTextEvent(this.file1, this.file2, this.key) : super._();

  @override
  final String? file1;
  @override
  final String? file2;
  @override
  final String key;

  @override
  String toString() {
    return 'FormatTextEvent.value(file1: $file1, file2: $file2, key: $key)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$ValueFormatTextEvent &&
            (identical(other.file1, file1) || other.file1 == file1) &&
            (identical(other.file2, file2) || other.file2 == file2) &&
            (identical(other.key, key) || other.key == key));
  }

  @override
  int get hashCode => Object.hash(runtimeType, file1, file2, key);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$ValueFormatTextEventCopyWith<_$ValueFormatTextEvent> get copyWith =>
      __$$ValueFormatTextEventCopyWithImpl<_$ValueFormatTextEvent>(
          this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() switchFormat,
    required TResult Function(String? file1, String? file2, String key) value,
  }) {
    return value(file1, file2, key);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? switchFormat,
    TResult? Function(String? file1, String? file2, String key)? value,
  }) {
    return value?.call(file1, file2, key);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? switchFormat,
    TResult Function(String? file1, String? file2, String key)? value,
    required TResult orElse(),
  }) {
    if (value != null) {
      return value(file1, file2, key);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(SwitchFormatTextEvent value) switchFormat,
    required TResult Function(ValueFormatTextEvent value) value,
  }) {
    return value(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(SwitchFormatTextEvent value)? switchFormat,
    TResult? Function(ValueFormatTextEvent value)? value,
  }) {
    return value?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(SwitchFormatTextEvent value)? switchFormat,
    TResult Function(ValueFormatTextEvent value)? value,
    required TResult orElse(),
  }) {
    if (value != null) {
      return value(this);
    }
    return orElse();
  }
}

abstract class ValueFormatTextEvent extends FormatTextEvent {
  const factory ValueFormatTextEvent(
          final String? file1, final String? file2, final String key) =
      _$ValueFormatTextEvent;
  const ValueFormatTextEvent._() : super._();

  String? get file1;
  String? get file2;
  String get key;
  @JsonKey(ignore: true)
  _$$ValueFormatTextEventCopyWith<_$ValueFormatTextEvent> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
mixin _$FormatTextState {
  bool get switchFormat => throw _privateConstructorUsedError;
  String get key => throw _privateConstructorUsedError;
  String get value1 => throw _privateConstructorUsedError;
  String get value2 => throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(
            bool switchFormat, String key, String value1, String value2)
        initial,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(
            bool switchFormat, String key, String value1, String value2)?
        initial,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(
            bool switchFormat, String key, String value1, String value2)?
        initial,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(InitialFormatTextState value) initial,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(InitialFormatTextState value)? initial,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(InitialFormatTextState value)? initial,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;

  @JsonKey(ignore: true)
  $FormatTextStateCopyWith<FormatTextState> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $FormatTextStateCopyWith<$Res> {
  factory $FormatTextStateCopyWith(
          FormatTextState value, $Res Function(FormatTextState) then) =
      _$FormatTextStateCopyWithImpl<$Res, FormatTextState>;
  @useResult
  $Res call({bool switchFormat, String key, String value1, String value2});
}

/// @nodoc
class _$FormatTextStateCopyWithImpl<$Res, $Val extends FormatTextState>
    implements $FormatTextStateCopyWith<$Res> {
  _$FormatTextStateCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? switchFormat = null,
    Object? key = null,
    Object? value1 = null,
    Object? value2 = null,
  }) {
    return _then(_value.copyWith(
      switchFormat: null == switchFormat
          ? _value.switchFormat
          : switchFormat // ignore: cast_nullable_to_non_nullable
              as bool,
      key: null == key
          ? _value.key
          : key // ignore: cast_nullable_to_non_nullable
              as String,
      value1: null == value1
          ? _value.value1
          : value1 // ignore: cast_nullable_to_non_nullable
              as String,
      value2: null == value2
          ? _value.value2
          : value2 // ignore: cast_nullable_to_non_nullable
              as String,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$InitialFormatTextStateCopyWith<$Res>
    implements $FormatTextStateCopyWith<$Res> {
  factory _$$InitialFormatTextStateCopyWith(_$InitialFormatTextState value,
          $Res Function(_$InitialFormatTextState) then) =
      __$$InitialFormatTextStateCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({bool switchFormat, String key, String value1, String value2});
}

/// @nodoc
class __$$InitialFormatTextStateCopyWithImpl<$Res>
    extends _$FormatTextStateCopyWithImpl<$Res, _$InitialFormatTextState>
    implements _$$InitialFormatTextStateCopyWith<$Res> {
  __$$InitialFormatTextStateCopyWithImpl(_$InitialFormatTextState _value,
      $Res Function(_$InitialFormatTextState) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? switchFormat = null,
    Object? key = null,
    Object? value1 = null,
    Object? value2 = null,
  }) {
    return _then(_$InitialFormatTextState(
      null == switchFormat
          ? _value.switchFormat
          : switchFormat // ignore: cast_nullable_to_non_nullable
              as bool,
      null == key
          ? _value.key
          : key // ignore: cast_nullable_to_non_nullable
              as String,
      null == value1
          ? _value.value1
          : value1 // ignore: cast_nullable_to_non_nullable
              as String,
      null == value2
          ? _value.value2
          : value2 // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc

class _$InitialFormatTextState extends InitialFormatTextState {
  const _$InitialFormatTextState(
      this.switchFormat, this.key, this.value1, this.value2)
      : super._();

  @override
  final bool switchFormat;
  @override
  final String key;
  @override
  final String value1;
  @override
  final String value2;

  @override
  String toString() {
    return 'FormatTextState.initial(switchFormat: $switchFormat, key: $key, value1: $value1, value2: $value2)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$InitialFormatTextState &&
            (identical(other.switchFormat, switchFormat) ||
                other.switchFormat == switchFormat) &&
            (identical(other.key, key) || other.key == key) &&
            (identical(other.value1, value1) || other.value1 == value1) &&
            (identical(other.value2, value2) || other.value2 == value2));
  }

  @override
  int get hashCode =>
      Object.hash(runtimeType, switchFormat, key, value1, value2);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$InitialFormatTextStateCopyWith<_$InitialFormatTextState> get copyWith =>
      __$$InitialFormatTextStateCopyWithImpl<_$InitialFormatTextState>(
          this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(
            bool switchFormat, String key, String value1, String value2)
        initial,
  }) {
    return initial(switchFormat, key, value1, value2);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(
            bool switchFormat, String key, String value1, String value2)?
        initial,
  }) {
    return initial?.call(switchFormat, key, value1, value2);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(
            bool switchFormat, String key, String value1, String value2)?
        initial,
    required TResult orElse(),
  }) {
    if (initial != null) {
      return initial(switchFormat, key, value1, value2);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(InitialFormatTextState value) initial,
  }) {
    return initial(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(InitialFormatTextState value)? initial,
  }) {
    return initial?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(InitialFormatTextState value)? initial,
    required TResult orElse(),
  }) {
    if (initial != null) {
      return initial(this);
    }
    return orElse();
  }
}

abstract class InitialFormatTextState extends FormatTextState {
  const factory InitialFormatTextState(
      final bool switchFormat,
      final String key,
      final String value1,
      final String value2) = _$InitialFormatTextState;
  const InitialFormatTextState._() : super._();

  @override
  bool get switchFormat;
  @override
  String get key;
  @override
  String get value1;
  @override
  String get value2;
  @override
  @JsonKey(ignore: true)
  _$$InitialFormatTextStateCopyWith<_$InitialFormatTextState> get copyWith =>
      throw _privateConstructorUsedError;
}
